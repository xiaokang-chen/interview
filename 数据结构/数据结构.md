# 数据结构

[toc]

![数据结构](/pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg)

## 数组和链表的优缺点

1. 数组
顺序存储，因为连续存储，所以内存空间必须一次性分配够，数组如果要扩容，需要重新分配一块更大的空间；通过索引可以快速找到对应元素，查找时间复杂度为O(1)；如果插入和删除，每次需要搬移后面的元素以保持所有数据连续，时间复杂度为O(N)；

2. 链表
乱序存储，靠指针指向下一元素的位置，所以不存数组扩容问题；因为没有索引，查找特定元素时，需要顺着指针查找，查找时间复杂度未O(N)；如果知道某个元素的前驱和后继，操作指针即可插入和删除，时间复杂度为O(1)；

## 数据访问方式

数据访问包括线性和非线性；线性就是循环迭代（for或while）、非线性就是递归
具体代码见`code/data_structure`

## 一、数组

## 二、链表

1. 什么时候需要虚拟头节点（dummy）

    当你需要创造一条新链表的时候，可以使用虚拟头节点简化边界处理情况的处理。比如
    `两条有序链表合并成一条新链表`，最后需要返回新的链表，就需要一个记录新链表头的“虚拟节点”

    虚拟头结点的技巧，也是为了防止出现空指针的情况。比如对于删除单链表倒数第k个节点：链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

## 三、树

![数据结构-树](/pic/数据结构-树.jpg)

### 3.1 二叉树

定义：每个节点最多包含两个子树的树称为二叉树

遍历方式：

1. 先序遍历
2. 中序遍历
3. 后序遍历
4. 深度优先遍历
5. 广度优先遍历

#### 3.1.1 二叉查找树

定义：又称二叉搜索树；

1. 任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值;
2. 任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值;
3. 任意节点的左右子树也为二叉查找树；
4. 没有键值相等的节点；

#### 3.1.2 平衡二叉树

定义：当且仅当任何节点的两棵子树的高度差不大于1的二叉树;

平衡二叉树是基于二叉查找树的改进. 由于在某些极端的情况下(如在插入的序列是有序的时), **二叉查找树将退化成近似链或链**, 此时,其他操作的时间复杂度将退化成线性的, 即O(n). 所有我们通过自平衡操作(即旋转)构建两个子树高度差不超过1的平衡二叉树.

##### 3.1.2.1 AVL树

##### 3.1.2.2 红黑树

定义：每个节点最多包含两个子树的树称为二叉树

1. 每个节点要么是红的要么是黑的；
2. 根节点是黑的；
3. 每个叶子节点都是黑的，且为null；
4. 连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；
5. 对于任意节点而言,其到叶节点树尾端NIL指针的每条路径都包含相同数目的黑节点(路径下黑相同)；
6. 新加入到红黑树的节点为红色节点；

红黑树调整：**旋转和变色**

应用场景：

1. Linux的虚拟内存管理
2. Java里TreeMap和TreeSet
3. Nginx中

#### 3.1.3 完全二叉树

#### 3.1.4 满二叉树

#### 3.1.5 哈夫曼树

## 四、图

## 五、哈希表

## 六、排序

## 七、查找
