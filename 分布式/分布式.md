# 分布式

[toc]

1. 乐观锁和悲观锁

乐观锁和悲观锁是两种思想，他们的使用非常广泛，不限于某种变成语言或者数据库。

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。`适用于读多写少的场景`
悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

悲观锁的实现方式是加锁，可以是对代码块进行加锁（比如go中的mutex.Lock()），也可以是对数据加锁（比如mysql的排他锁-X）
乐观锁的实现方式有两种，CAS机制和版本号机制。`乐观锁本身不加锁`

- CAS（compare and swap）：go中的atomic属于乐观锁。CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的，是不会被线程调度打断的操作。
因此该操作一旦开始，就一直运行到结束，中间不会有任何 context switch（上下文切换），这确保了对于原子操作的执行不会有并发问题。
- 版本号机制：版本号机制的思路是在数据中加一个字段version，表示数据的版本号，每当数据被修改，版本号+1。
当某个线程查询数据的时，将版本号一起查出来，当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，一致才进行更新操作。
