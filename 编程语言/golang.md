# Golang

[toc]

## 一、golang 中 make 和 new 的区别

1）作用变量类型不同，new给string,int和数组分配内存，make给切片，map，channel分配内存；
2）返回类型不一样，new返回指向变量的指针，make返回变量本身；
3）new 分配的空间被清零。make 分配空间后，会进行初始化；

## 二、数组和切片的区别

1）定义方式不一样；
2）初始化方式不一样，数组需要指定大小，大小不改变；
3）在函数传递中，数组切片都是值传递；

数组和切片的定义及初始化：

```golang
// 数组
var a1 [3]int // 声明式
var a2 [...]int{1,2,3} // 推导式
a3 := [5]int{1,2,3}
var a4 = new([4]int)

// 切片
// 因为是动态扩容，所以更常用一些
// 扩容策略：小于1024则翻倍，大于1024则增加25%容量
var a1 []int
var a2 := make([]int, 3, 5) // len=3; cap=5
```

## 三、rune类型是什么，怎么用

rune是int32类型的别名，在各方面都等价于它，用来区分字符串和整数值，使用单引号定义。用途如下：

1. 统计带中文字符串的长度

    ```go
    fmt.Println(len("Go编程语言"))         // 14
    fmt.Println(len([]rune("Go编程语言"))) // 6
    ```

2. 截取带中文的字符串

    ```go
    // 对于包含中文的字符串，如果用rune，可以很方便的根据
    // 需要截取的位置进行对包含中文字符串进行截断
    s := "Go编程语言"
    fmt.Println(s[:8])                 // Go编程
    fmt.Println(s[:7])                 // Go编�
    fmt.Println(string([]rune(s)[:4])) // Go编程
    ```

## 四、golang 中解析 tag 是怎么实现的？反射原理是什么？

Go 中解析的 tag 是通过反射实现的，反射将接口变量转换成反射对象 Type 和 Value。
反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值。
tag是啥:结构体支持标记。

## 五、golang 中的 gc

Go V1.3：标记清除法，整体过程需要STW（stop the world），效率极低；
Go V1.5：三色标记法，堆空间进行写屏障，栈空间不启动，全部扫描完后，需要重新扫描一次栈，效率普通；
Go V1.8：三色标记+混合写屏障，栈空间不启动，堆空间启动，整个空间几乎不需要STW，效率较高；

1. 三色标记法扫描过程中，如果不受STW保护，当满足下面两个条件，会出现对象丢失的情况

      - 条件1：一个白色对象被黑色对象引用
      - 条件2：一个白色对象被上游灰色对象断开

2. 为了去除STW，并且不出现对象丢失的情况，引入强弱三色不变式，只要满足之一即可

     - 强三色不变式（破坏条件1）：强制不允许黑色对象引用白色
     - 弱三色不变式（破坏条件2）：黑色对象可以引用白色对象，但是白色对象上游必须包含灰色对象

3. 屏障机制

    - 插入屏障：插入一个对象时，标记该对象为灰色；不足：结束时需要STW重新扫描栈
    - 删除屏障：删除一个对象时，标记该对象为灰色；不足：回收精度低，一个对象即使被删除了，最后一个指向它的指针也能活过这一轮，在下一轮GC中被清除掉

4. 混合写屏障（最优）
    1）GC开始时，将栈上全部对象扫描，并标记为黑色；（之后不需要重新扫描，无需STW）
    2）GC期间，任何栈上的创建对象，均标记为黑色；
    3）被删除的对象标记为灰色；
    4）被添加的对象标记为灰色；

## 六、golang 中的内存管理

栈内存：「栈内存」是计算机对`连续内存`（虚拟内存）采取的「线性分配」管理方式，便于高效存储指令运行过程中的临时变量。
堆内存：

## 七、golang 中的GMP
