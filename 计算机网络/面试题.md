# 计算机网络面试题

参考：https://zhuanlan.zhihu.com/p/466239718

[toc]

## 浏览器输入url到返回资源

当我们在浏览器地址输入栏输入了一段地址之后会有如下操作依次发生：
![浏览器输入url到返回资源](../pic/输入url后.jpeg)

## tcp协议

参考：[TCP连接的过程](https://blog.csdn.net/weixin_51338848/article/details/127691543)

1. tcp三次握手
![三次握手](../pic/tcp三次握手.jpeg)

    - 一开始客户端和服务端都处于`close`状态
    - 服务端主动监听一个端口，进入`listen`状态
    - 客户端发送SYN包（表示希望简历TCP连接），其中SYN的值是随机生成的序列号，将请求报文
    发送给服务端后，自己进入`sync_send`状态
    - 服务端接收到客户端发送的SYN包，会返回一个ACK包（确认，其值为client_num + 1）和一个SYN包。
    同时ACK和SYN的标记位置为1，将报文发送到客户端，自己进入`sync_rcvd`状态
    - 此时客户端收到来自服务端的确认包，可以保证客户端已经接收到了他的请求，此时需要发送一个ACK确认包，值为server_num + 1，并将ACK标记位置为1，发送报文后自己进入`established`状态
    - 服务端接收到来自客户端发送的报文后，进入`established`状态，此时双方建立连接

2. tcp四次挥手
![四次挥手](../pic/tcp四次挥手.jpeg)

3. 为什么不采用两次握手，一定要三次

4. 为什么要有 TIME_WAIT

5. tcp流量控制
使用滑动窗口实现

## rpc协议

RPC本身叫作“远程过程调用”，它是一种调用方式，本质上不是某一个协议。
`rpc协议是基于传输层tcp/udp之上使用rpc思想自定义的应用层协议。`

1. RPC的通信流程

   - 函数映射：通过编译工具，将proto文件打桩，桩文件让远程调用看起来像本地调用
   - 序列化/反序列化：http1直接发送json，明文传输，而grpc使用protobuf作为序列化协议
   - 网络传输：自定义一些rpc协议，实现应用层通信，下层使用成熟的网络库使用tcp进行通信（会采用多路复用...）

2. RPC和HTTP的区别

     - 编解码
     http1.1：使用json序列化协议，额外空间开销大。不带类型，开发时需要反射；
     rpc：以grpc为代表的protobuf，序列化后体积比json小。序列化和反序列化速度快，开发时不需要反射，并且IDL描述定义比较清晰；
     - 通信协议约定
    http1.1：优点是灵活，可以自定义头部字段；缺点是头部包含了很多适应浏览器的冗余信息，这些在服务间调用时是用不到的；
    rpc：可定制化，头部字段可以自定义；
     - 网络传输
    http1.1：使用keep-alive建立一个tcp长连接，框架会引入网络库去给HTTP加连接池，确保可以有多个tcp连接可用；
    rpc：grpc基于http2，具备多路复用、优先级控制、头部压缩等优点；本身是基于连接池，会比http没有加连接池时快很多；

    总结：外部服务（浏览器调用）使用http、内部服务（服务调用）调用使用rpc
3. RPC框架都做了哪些事

   - 编解码层
    （1）生成代码：利用代码生成工具将IDL文件转换成不同语言可以依赖的lib文件
    （2）序列化&反序列化：对象和二进制字节流之间的转化
   - 协议层
    （1）支持解析多种协议
    （2）协议需要知道哪几个tcp数据包是一条请求的（tcp传输时会被拆分和合并）
   - 网络传输层
    （1）实现高并发（I/O多路复用）、可靠传输
   - 服务治理层（拓展）
    （1）服务端：服务注册、健康检查、限流
    （2）客户端：服务发现、路由策略、负载均衡、重试机制、故障熔断
    （3）其他功能：跟踪链、日志、监控
