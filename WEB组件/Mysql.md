# Mysql

[toc]

## 一、基础

### 1.1 SQL执行流程

![SQL执行流程](/pic/SQL执行流程.jpg)

1. 连接器建立连接
2. 查询缓存（MySQL8.0已删除）
3. 解析SQL：词法分析、语法分析、构建语法树
4. 执行SQL：预处理、优化、执行

### 1.2 记录的存储

MySQL 存储的行为是由存储引擎实现的，默认是InnoDB。
数据库创建一张表，会在文件系统中创建三个文件（8.0之前，8.0之后只会创建idb）：

1. db.opt
2. frm表结构文件
3. ibd表数据文件

如果要是开启表分区，那么一个表分区就会对应一个ibd文件。

### 1.3 InnoDB逻辑存储结构

表空间由段（segment）、区（extent）、页（page）、行（row）组成

![InnoDB逻辑存储结构](/pic/InnoDB逻辑存储结构.jpg)

1. 行（row）
    数据表中的记录都是按行进行存放的，每行记录根据不同的行格式，有不同的存储结构。

    `行格式`就是一条记录的存储结构，InnoDB提供了4种行格式：

    - Redundant（弃用）
    - **Compact**
    - Dynamic（紧凑型，基于Compact）
    - Compressed（紧凑型，基于Compact）

2. 页（page）
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。
InnoDB 的数据是按「页」为单位来读写的，默认每个页大小为16K，数据表中的行记录用【数据页】来管理。

3. 区（extent）
InnoDB 存储引擎是用 B+ 树来组织数据的。B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。
所以为了使链表中相邻的页的物理位置也相邻（便于顺序I/O），在范围查询（扫描叶子节点）时性能变高：
**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。**

4. 段（segment）
段一般分为数据段、索引段、回滚段等：

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放回滚数据的区的集合；

### 1.4 Compact行格式

![MySQL_COMPACT](/pic/MySQL_COMPACT.jpg)

#### 1.4.1 记录的额外信息

包括`变长字段长度列表`、`NULL值列表`、`记录头信息`

1. 【变长字段长度列表】、【NULL值列表】中的信息为什么要逆序存放？
因为可以提高CPU Cache的命中率

2. NULL值如何存储
NULL值会存储在【NULL值列表】中，如下图：
![COMPACT数据格式](/pic/COMPACT数据格式.jpg)
「NULL 值列表」的空间不是固定 1 字节的。
当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推

3. 记录头信息
【记录头信息】存储的内容很多，重要的包括：

- delete_mask：标识数据是否被删除
- next_record：下一条记录的位置
- record_type：当前记录的类型

#### 1.4.2 记录的真实数据

- row_id：如果建表的时候指定了主键或唯一约束列，就没有row_id隐藏字段了
- trx_id：事务id
- roll_pointer：上一个版本的指针

### 1.5 varchar(n)

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节；

1. varchar(100)最大能存储多少个字符，需要多少字节？
对于不同字符集，存储的字节不同。英文字符固定都是一个字节，汉字字符根据编码方式占不同字节，Utf-8占3个字节，gbk占了2个字节。
所以对于gbk和utf-8来说，都能存储100个字符（英文、数字、汉字...）。但是存储100个汉字时，gbk会消耗200个字节，utf-8会消耗300个字节

- 当编码形式为utf8时varchar最大可以存(65535字节-2字节 )/3字节=21844字符余1,大概21844个汉字,也就是说可以设置的最大长度为21844
- 当编码形式为GBK时varchar最大可以存(65535字节-2字节)/2字节=32766字符余1,大概32766个汉字,也就是说可以设置的最大长度为32766

### 1.6 数据行溢出

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是16384字节。当存储数据大于16K时，就会发生行溢出，多的数据就会存到另外的【溢出页】中，如下图：
![MySQL行溢出](/pic/MySQL行溢出.jpg)

### 1.7 其他

1. mysql按照页（16Kb）为单位进行磁盘数据I/O的最小单位，和操作系统原理类似（4Kb）。

## 二、索引

### 2.1 索引分类

按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
按「字段个数」分类：单列索引、联合索引。

#### 2.1.1 按数据结构分类

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型
在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

1. 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
2. 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
3. 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

**创建的主键索引和二级索引默认使用的是 B+Tree 索引。**

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。

**通过主键查询商品数据的过程：**
![主键索引B+](/pic/主键索引B+.jpg)

对于下面这条语句：

```SQL
select * from product where id= 5;
```

- 将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；
- 在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；
- 在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据；

数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作
B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以`B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次`。

**通过二级索引查询商品数据的过程：**
主键索引的 B+Tree 的叶子节点存放的是实际数据，`二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据`。
![二级索引B+](/pic/二级索引B+.jpg)
其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中叶子白色部分）。

如果用product_no二级索引查询商品，如下图语句：

```SQL
select * from product where product_no = '002';
```

会先去`二级索引B+树`中检索二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值2。再去`主键索引B+树`中查询主键对应的叶子节点，然后获取整行数据，<font color='red'>这个过程叫【回表】，就是说要查两个B+树才能查到数据</font>。

如果查询的数据（比如只查询id）在二级索引B+树的叶子节点能查询到，这时就不需要【回表】了，如下面这条语句：

```SQL
select id from product where product_no = '0002';
```

<font color='red'>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作【覆盖索引】，也就是只需要查一个 B+Tree 就能找到数据</font>。

#### 2.1.2 按物理存储分类

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引），区别在于：

- 主键索引的B+树的叶子节点存放的是实际数据；
- 二级索引的B+树的叶子节点存放的是主键值；

所以，在查询时使用了二级索引，如果查询的数据能在二级索引中查询到，就不需要回表，这个过程叫作【覆盖索引】；如果查询的数据不在二级索引中，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，再去检索主键索引，就能查到数据了，这个过程叫作【回表】。

#### 2.1.3 按字段特性分类

分为主键索引、唯一索引、普通索引、前缀索引

1. 主键索引
主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
2. 唯一索引
唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
3. 普通索引
普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。
4. 前缀索引
前缀索引是指对**字符类型**字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。`使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率`。

#### 2.1.4 按字段个数分类

分为单列索引、联合索引

**单列索引：**
建立在单列上的索引，比如主键索引

**联合索引：**
将多个字段组合成一个索引，比如将商品表中`product_no`和`name`组合成联合索引`(product_no, name)`，联合索引的B+树如下：
![联合索引B+树](/pic/联合索引B+树.jpg)

使用联合索引时，遵循`最左匹配原则`，这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：
![联合索引(a,b)B+树](/pic/联合索引(a,b)B+树.jpg)
可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行where b = 2这种查询条件没有办法利用联合索引的，**利用索引的前提是索引里的 key 是有序的**。
只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行where a = 2 and b = 7是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。

### 2.2 联合索引

#### 2.2.1 联合索引范围查询

```SQL
-- SQL1: 
-- 符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的
-- 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引
select * from t_table where a > 1 and b = 2;

-- SQL2
-- 对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的
-- 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
select * from t_table where a >= 1 and b = 2;

-- SQL3
-- 联合索引：（name, age）
-- 在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<
-- 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
select * from t_table where a between 2 and 8 and b = 2

-- SQL4
-- 对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的
-- 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
select * from t_user where name like 'j%' and age = 22
```

综上所示，联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面也用了四个例子说明了。

#### 2.2.2 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。
比如对于`select * from table where a > 1 and b = 2`，会先对b=2进行判断，过滤掉不满足条件的记录。

#### 2.2.3 索引区分度

建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，`要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到`。区分度就是某个字段 column 不同值的个数「除以」表的总行数。比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。

#### 2.2.4 联合索引进行排序

对下面这条SQL，通过索引进行查询效率提升：

```SQL
select * from order where status = 1 order by create_time asc
```

在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。
所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。

### 2.3 从数据页的角度看B+树

1. InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。
2. 每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。
3. 数据页内包含用户记录，每个记录之间用单向链表的方式组织起来。为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。
![B+树的物理结构](/pic/B+树的物理结构.jpg)

### 2.4 选用B+树作为索引的原因

要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：

1. 能在尽可能少的磁盘的 I/O 操作中完成查询工作；
2. 要能高效地查询某一个记录，也要能高效地执行范围查找；
3. 在满足1.2的前提下尽可能提高插入、删除操作速度；

#### 2.4.1 顺序表

索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。试想在几万条数据中头部插一条数据，需要挪动几万条数据的位置（几万次磁盘I/O），这是灾难性的。所以<font color='red'>不适合作为数据库索引结构！！！</font>

#### 2.4.2 二分查找树

二分查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点。我们在查询数据的时候，不需要计算中间节点的位置了，只需要将数据与节点的数据进行比较：
如果key小于根节点，则去左子树查找；
如果key大于根节点，则去右子树查找；
如果key等于根节点，返回根节点；

二叉查找树解决了顺序表插入新元素开销很大的问题。但是当遇到极端情况下，会导致它变为一个瘸子：
**每当插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化为一条链表，查找数据的复杂度就变为了O(N)**

而且随着插入的元素越来越多，树的高度也变高，查询时，磁盘I/O操作就会变多。并且还不能范围查询，所以<font color='red'>不适合作为数据库索引结构！！！</font>

#### 2.4.3 平衡二叉树

平衡二叉树又称AVL树。它在二叉查找树的基础上增加约束：`每个节点的左子树和右子树的高度差不能超过1`，这就防止了二叉查找树的退化问题。
但是依然没有解决树高度变高的问题（因为是二叉的原因，所以节点变多，必然会导致树变高），所以<font color='red'>不适合作为数据库索引结构！！！</font>

#### 2.4.4 B树

![MySQL_B树](/pic/MySQL_B树.png)
B树不再限制一个节点就只能有2个子节点，而是允许M个子节点 (M>2)，又称为`多路平衡查找树`，其中M称为B树的阶。B树在查找的时候还存在一些问题：

1. B树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」；
2. 当查找位于底层某个节点（比如A记录）时，【非A记录节点】的数据也会从磁盘加载到内存，但是这些数据对于整个查找结果来说是没用的，我们指向读取这些【非A记录节点】的索引，而非数据；
3. 使用B树做范围查询的话，需要`中序遍历`，这会涉及多个节点的磁盘I/0问题，从而导致整体速度下降；

基于以上三点，B树<font color='red'>不适合作为数据库索引结构！！！</font>

#### 2.4.5 B+树

![MySQL_B+树](/pic/MySQL_B+树.png)

B+ 树就是对 B 树做了一个升级，B+ 树与 B 树差异的点，主要是以下这几点：

1. 叶子节点才会存放实际数据（索引+记录），非叶子节点只会存放索引；
2. 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
3. 非叶子节点的索引也会同时存在于叶子节点，并且是叶子节点中所有索引的最大（或最小）；
4. 非叶子节点中有多少个子节点，就有多少个索引；

相对B数来说，B+树有以下优势：

1. 在单点查询上，B+树更【矮胖】，所以对于底层节点的查询，磁盘I/0更少；
2. 在插入和删除效率上，B+树非叶子节点上有冗余节点，所以会自动平衡，不需要复杂的树的调整操作；
3. 在范围查询上，B+树所有叶子几点间有一个链表进行连接，这种设计对范围查询非常有帮助；

基于以上，B+树<font color='green'>适合作为数据库索引结构！！！</font>

### 2.5 回表、索引覆盖、索引下推

1. 回表：
使用二级索引进行数据查找的时候，需要根据主键去主键索引树中再查找一次完整的数据记录，这个过程叫作**回表**

2. 索引覆盖：
查询的数据结果在二级索引中，也即在二级索引的B+树中就能查询到结果的过程叫作**覆盖索引**

3. 索引下推：
MySQL5.6引入的新特性，目的是减少回表。对于下面这条SQL：

    ```SQL
    select * from table where a > 1 and b = 2
    ```

    上面的语句只有a字段用到索引，在联合索引B+树中找到第一个满足条件的主键值（ID=2）后，还需要判断其他条件是否满足，这个判断是去`联合索引树`还是`主键索引树`中？MySQL5.6之前只能**回表**去主键索引树中找到数据行，再对比b字段值；而MySQL5.6的**索引下推**可以在联合索引遍历过程中，对联合索引中包含的字段进行判断，直接在`联合索引树`中过滤掉不满足的记录，减少回表次数。

## 三、事务

### 3.1 事务的特性

1. **原子性：**
一个事务的所有操作，要么全部完成，要么全部失败。利用`回滚日志（undo log）`来保证；
2. **一致性：**
A向B转账，要保证A的钱少了，B的钱多了，而不是B未增加的情况。`持久性+原子性+隔离性`来保证。
3. **隔离性（重点）：**
数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。利用`重做日志（redo log）`来保证；
4. **持久性：**
事务处理结束，对数据的修改是永久的，即便系统故障也不会丢失；利用`多版本并发控制`或`锁机制`来保证

### 3.2 并发事务

并发事务可能会出现以下问题：

1. 脏读
A、B两个事务同时在处理，A执行到更新操作后，还未提交事务，此时B读数据，而后续A回滚操作，那么B就读了“过期的数据”，这种现象称为**脏读**。
2. 不可重复读
A、B两个事物同时在处理，A先执行读操作，B此时进行数据更新操作并提交事务，此时A再次读数据（该数据被B更新），就会出现前后两次读到的数据不一致，这种现象称为**不可重复读**。
3. 幻读
A、B两个事物同时在处理，B先执行查询符合条件的【记录数量】，此时A进行数据插入操作（该数据刚好满足B的查询条件），此时B再去查询符合条件的【记录数量】，就会出现前后两次查询记录的数量不一致的情况，这种现象称为**幻读**。

三种现象的严重性为：<font color='red'>脏读 > 不可重复读 > 幻读</font>

### 3.3 事务隔离级别

SQL 标准提出了四种隔离级别来规避并发事务出现的问题，隔离级别越高，性能效率就越低，这四个隔离级别如下：

1. 读未提交：一个事务还没提交时，它的变更就能被其他事物看到；
2. 读已提交：一个事务提交之后，它做的变更才能被其他事务看到；
3. **可重复读（重要）：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；**
4. 串行化：对记录加读写锁，多个事务对记录进行读写操作时，如果发生读写冲突，后访问的事务必须等待前一个事务执行完成，才能继续执行；

针对不同的隔离级别，并发事务时可能发生的现象也会不同：
![MySQL事务隔离级别](/pic/MySQL事务隔离级别.jpg)

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象。

## 四、锁

### 4.1 锁分类

#### 4.1.1 全局锁

```SQL
flush tables with read lock
```

执行后，`整个数据库就处于只读状态了`，这时其他线程执行以下操作，都会被阻塞。想释放全局锁，执行下面的命令：

```SQL
unlock tables
```

应用场景：全库备份时，对数据库加只读锁，此时业务不可增删改。要解决备份期间业务可用，就使用支持`可重复读的隔离级别`的数据库引擎，并在备份数据库前开启事务，这时会先创建Read View（快照），备份这个事务执行期间都是在用这个快照。

#### 4.1.2 表级锁

1. 表级锁

    ```SQL
    -- 表级别的读锁（共享锁）
    -- 事务A加共享锁后，其他事务可以读该数据，不可以写该数据
    lock tables t_table read;

    -- 表级别的写锁（排它锁）
    -- 事务A加排它锁后，只允许失误A对数据进行读写操作，其他事务不可对该数据进行读写操作
    lock tables t_table write;

    -- 释放锁
    unlock tables
    ```

    表级锁除了会限制别的限制读写外，对当前线程接下来的读写也会阻塞，直到锁被释放。表锁的颗粒度太大，会影响并发性能。

2. 元数据锁

    不需要显式的使用元数据锁（MDL），因为在对数据库表进行操作时，会自动给表加元数据锁：

    - 对一张表进行CRUD时，加的是MDL读锁
    - 对一张表做结构变更时，加的是MDL写锁

3. 意向锁

    意向锁的目的是为了快速判断表里是否有记录被加锁。
    意向共享锁和意向独占锁是表级锁，`不会和行级的共享锁和独占锁发生冲突`，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。

4. AUTO-INC锁（自增锁）

    表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。
    之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。
    一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。

#### 4.1.3 行级锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

## 五、日志

## 六、内存

## 七、面试题

### 7.1 MySQL 中 InnoDB 和 MyISAM 的联系与区别

MySQL数据库对多引擎有很好的兼容，一个数据库中多个表可以使用不同的引擎。

- 对事务要求比较高的表选用InnoDB；
- 对查询要求比较高的选用MyISAM；
- 需要查询的临时表，选用MEMORY（Hash based，存储在内存中）；

区别：

- 事务：InnoDB支持事务，MyISAM不支持；
- 外键：InnoDB支持外键，MyISAM不支持；
- 存储引擎原理：两种引擎都是B+树。MyISAM 中 B+ 树的数据结构存储的内容是实际数据的地址值，它的索引和实际数据是分开的，这种索引的模式被称为非聚集索引；InnoDB 中 B+ 树的数据结构中存储的都是实际的数据，这种索引有被称为聚集索引；
- 索引：MyISAM-非聚集索引；InnoDB-聚集索引；

**MyISAM索引：**
MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。
![MyISAM索引](/pic/MyISAM索引.jpg)

**InnoDB索引：**
由于 InnoDB 利用的数据库主键作为索引 Key，所以 InnoDB 数据表文件本身就是主索引，且因为 InnoDB 数据文件需要按照主键聚集，所以使用 InnoDB 作为数据引擎的表需要有个主键，如果没有显式指定的话 MySQL 会尝试自动选择一个可以唯一标识数据的列作为主键，如果无法找到，则会生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形
![InnoDB索引](/pic/InnoDB索引.jpg)

总结：

1. MyISAM管理非事务表，它提供高速存储和检索。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
2. InnoDB用于事务处理应用程序。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

### 7.2 MySQL 中 B+树 和 B树 的比较

1. 单点查询：
B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
2. 范围查询：
B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
3. 插入和删除：
B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；

### 7.3 索引适用场景

适用场景：

1. 字段有唯一性限制，比如商品编码；
2. 经常用于where查询条件的字段；
3. 经常用于 group by 和 order by 的字段；

不适应场景：

1. where、group by、order by里用不到的字段；
2. 字段中存在大量重复数据，即区分区低的字段，如性别；
3. 表数据少的情况；
4. 经常更新的字段（索引字段频繁修改，由于需要维护B+树的有序性，需要频繁的重建索引）；

### 7.4 什么时候索引会失效

1. 使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；
2. 在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
3. 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效；
4. 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效；
**因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描；**

### 7.5 索引优化方法

1. 前缀索引优化（针对一些大字符串字段作为索引时，使用前缀索引减小索引项的大小）；
2. 覆盖索引优化（使用二级索引时，查询数据都可以直接在二级索引B+树上找到，从而避免回表。比如业务上只需要查询出商品的`名称`和`价格`，那么就建立一个【商品ID、名称、价格】的联合索引）；
3. 主键索引最好是自增的；
自增主键每次插入都是`追加`操作，不需要重新移动数据；如果使用非自增主键，就会出现**页分裂**，如下图：
![MySQL页分裂](/pic/MySQL页分裂.jpg)
4. 防止索引失效（写SQL语句的时候需要注意避免索引失效）；

### 7.6 count(*)和count(1)区别

结论：
![MySQL_count()性能](/pic/MySQL_count()性能.jpg)

count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

### 7.7 慢查询如何优化

1. 检查是否走了索引，如果没有则优化SQL利用索引；
2. 检查利用的索引，看是否是最优索引；
3. 检查查找字段是否都必须，是否查询了多余的字段以及数据；
4. 检查表中数据是否过多（是否多余2000W），不要让B+树从3层变成4层，可以考虑分库分表、表分区；
5. 检查数据库读流量是否过大，可以考虑读写分离；

#### 分库分表

分为`垂直切分`和`水平切分`

1. 水平：将数据分散到多张表
  
    - 分库：每个库结构一样，数据不一样，没有交集，多库缓解单机cpu和io压力；
    - 分表：每个表结构一样，数据不一样，没有交集，表数量减少可以提高sql执行效率；

2. 垂直：将字段拆分为多张表，需要改表结构（适合表字段过多的情况）

    - 分库：每个库结构、数据都不一样，所有库的并集为全量数据；
    - 分表：每个表结构、数据都不一样，至少有一列交集（外键），用于关联数据，所有表的并集为全量数据；

**存储拆分后唯一ID怎么解决：**

1. 基于UUID（无顺序。不适合做范围查询，存在MAC地址泄漏风险）
2. 数据库主键（初始值不同，步长相同--奇偶交替）
3. Redis生成ID
4. 雪花算法（按照时间趋势递增）
5. ID缓冲环

### 表分区

比如可以根据日期将数据表分区，提高where语句按照日期查询的效率；

#### 读写分离

写请求打到master上，读请求打到slave上，数据同步靠主从复制。

### 7.8 MVCC

`多版本并发控制`只在**读已提交**和**可重复读**两个隔离级别下才生效，它通过 Read View 实现。
需要了解 Read View 四个字段以及聚簇索引记录中的两个隐藏列：

Read View 包括：

- 活跃事务id列表，活跃事务即启动了但未提交的事务；
- 活跃事务中的最小事务id；
- 全局事务的最大id；
- 创建 Read View的事务id；

InnoDB聚簇索引包含的两个隐藏列：

- trx_id：对聚簇索引记录进行修改的事务id；
- roll_pointer：每次对聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log 中，该变量指向每一个旧版本的记录；（上个版本地址）

通过对比记录的**trx_id**和 Read View 中的字段来控制某个版本的记录对当前事务是否可见，这种通过【版本链】来控制并发事务访问同一记录的行为就是MVCC。

1. 开始事务时创建 Read View，它会维护当前活动的事务id，即未提交的事务id，排序生成一个数组；
2. 访问数据，获取数据中的事务id（事务id最大的记录），对比 Read View；
3. 如果记录的事务id在 Read View 左边（比read view小），可以访问（在左边意味着该事务已提交）；
4. 如果记录的事务id在 Read View 右边（比read view大）或者就在 Read View中，不可以访问（在右边或列表中意味着该事务未提交），获取roll_pointer，取上一版本重新对比；

### 7.9 MySQL主从同步

主从复制主要有三个线程：master（binlog dump thread）、slave（I/O thread）、SQL thread。主节点一条线程，子节点两条线程。

- 主节点binlog，binlog会从数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件；
- 主节点log dump线程会检测binlog变动，读取其内容并发送给从节点；
- 从节点I/O线程接收binlog内容，并将其写入relay log文件中；
- 从节点SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性；
- 主节点会记录每次同步的位置（偏移量），实现`增量同步`；

由于MySQL默认复制是异步的，主库把日志发给从库不关系从库是否已经处理，这样就会导致：如果主库挂了，从库处理失败，这时从库升级为主库后，日志就丢失了，这里就产生两个概念：

1. 全同步复制
主库写入binlog后强制同步日志到从库，所有从库都执行完成后才返回客户端，这个方式性能会受到严重影响；

2. 半同步复制
从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成（确保数据不丢失）；

### 7.10 事务ACID如何保证

1. A：原子性
依赖undo-log（回滚日志），它记录需要回滚的日志信息，事务回滚时撤销已经执行成功的sql；
2. C：一致性
保证了AID，就会达到一致性的结果；
3. I：隔离性
依赖MVCC（多版本控制）
4. D：持久性
依赖redo-log（重做日志），mysql修改数据的同时在内存和redo-log记录这次操作，宕机的时候可以从redo-log中恢复；

更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：

### 7.11 事务的隔离级别实现

并行事务会导致：

- 脏读
- 不可重复读
- 幻读

MySQL隔离级别包括：读未提交、读已提交、可重复读（默认）、串行化。不同级别的隔离会导致在并行事务中读到的数据也不同。四种隔离级别的实现方式：

- 读未提交：直接可以读到未提交事务的数据，所以直接读取即可；
- 可串行化：通过加读写锁；
- 读已提交、可重复读：通过 Read View 实现，Read View即数据快照；

读已提交下，事务在每次查询开始都会生成一个独立的 Read View；
可重复读下，事务只在第一次读的时候生成一个 Read View，后面读都复用之前的 Read View（只生成一次，性能高一些）；
